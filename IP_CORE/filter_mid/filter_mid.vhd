--------------------------------------------------------------------------------
--
-- Design unit generated by Aldec IP Core Generator, version 10.5.
-- Copyright (c) 1997 - 2018 by Aldec, Inc. All rights reserved.
--
--------------------------------------------------------------------------------
--
-- Created on Thursday 2020-02-06, 11:40:43
--
--------------------------------------------------------------------------------
-- Details:
--		Type: Serial Distributed Arithmetic FIR filter
--		Data input DATA width: 24
--		Data output OUT_READY width: 24
--		Coefficient width: 31
--		Taps number: 31
--		Filter is non-symmetric
--------------------------------------------------------------------------------

--{{ Section below this comment is automatically maintained
--   and may be overwritten
--{entity {filter_mid} architecture {filter_mid}}

library IEEE;
use IEEE.std_logic_1164.all;
entity filter_mid is
	port(
		DATA : in std_logic_vector(23 downto 0);
		RSLT : out std_logic_vector(23 downto 0);
		CLK : in std_logic;
		RESET : in std_logic;
		NEW_READY : out std_logic;
		OUT_READY : out std_logic
	);
end entity;

--}} End of automatically maintained section

library IEEE;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
-- synopsys translate_off
library UNISIM;
use UNISIM.VCOMPONENTS.all;
-- synopsys translate_on

architecture filter_mid of filter_mid is

component RAM32X1S is 
	port(
		D : in std_logic;
		A4 : in  std_logic;
		A3 : in  std_logic;
		A2 : in  std_logic;
		A1 : in  std_logic;
		A0 : in  std_logic;
		WE : in  std_logic;
		WCLK : in  std_logic;
		O : out std_logic);
end component;

type ROM4 is array(0 to 15) of std_logic_vector(31 downto 0);
constant MEM4 : ROM4 := ("00000000000000000000000000000000","00001111011110111001001000100111","00010000010011010111100101100011","00011111110010010000101110001010","00010000111100001111101001101111","00100000011011001000110010010111","00100001001111100111001111010011","00110000101110100000010111111010","00010001010001011100111100010000","00100000110000010110000100110111","00100001100100110100100001110011","00110001000011101101101010011011","00100010001101101100100110000000","00110001101100100101101110100111","00110010100001000100001011100011","01000001111111111101010100001011");
type ROM5 is array(0 to 15) of std_logic_vector(31 downto 0);
constant MEM5 : ROM5 := ("00000000000000000000000000000000","00010001011000111111000101011001","00010001010001011100111100010000","00100010101010011100000001101010","00010000111100001111101001101111","00100010010101001110101111001001","00100010001101101100100110000000","00110011100110101011101011011010","00010000010011010111100101100011","00100001101100010110101010111101","00100001100100110100100001110011","00110010111101110011100111001101","00100001001111100111001111010011","00110010101000100110010100101101","00110010100001000100001011100011","01000011111010000011010000111101");
type ROM3 is array(0 to 15) of std_logic_vector(30 downto 0);
constant MEM3 : ROM3 := ("0000000000000000000000000000000","0001010111001011100111111001011","0001100001010001010010011010110","0010111000011100111010010100010","0001101010110111101111010101000","0011000010000011010111001110100","0011001100001001000001101111111","0100100011010100101001101001010","0001110100000100011101111001110","0011001011010000000101110011010","0011010101010101110000010100101","0100101100100001011000001110000","0011011110111100001101001110111","0100110110000111110101001000010","0101000000001101011111101001101","0110010111011001000111100011001");
type ROM1 is array(0 to 7) of std_logic_vector(30 downto 0);
constant MEM1 : ROM1 := ("0000000000000000000000000000000","1011001001001111000100101101111","0000110001110101111111010001011","1011111011000101000011111111011","0000110010111101011000110101110","1011111100001100011101100011101","0001100100110011011000000111010","1100101110000010011100110101001");
type ROM2 is array(0 to 15) of std_logic_vector(30 downto 0);
constant MEM2 : ROM2 := ("0000000000000000000000000000000","0000110110101100010001111110010","0000111100110010011001101010101","0001110011011110101011101000111","0001000100100010101101110000111","0001111011001110111111101111001","0010000001010101000111011011100","0010111000000001011001011001110","0001001101101000010000101000001","0010000100010100100010100110100","0010001010011010101010010010111","0011000001000110111100010001001","0010010010001010111110011001001","0011001000110111010000010111011","0011001110111101011000000011110","0100000101101001101010000010000");
type ROM6 is array(0 to 15) of std_logic_vector(30 downto 0);
constant MEM6 : ROM6 := ("0000000000000000000000000000000","0001111011110111001001000100111","0001110100000100011101111001110","0011101111111011100110111110101","0001101010110111101111010101000","0011100110101110111000011001111","0011011110111100001101001110111","0101011010110011010110010011110","0001100001010001010010011010110","0011011101001000011011011111101","0011010101010101110000010100101","0101010001001100111001011001100","0011001100001001000001101111111","0101001000000000001010110100110","0101000000001101011111101001101","0110111100000100101000101110101");
type ROM7 is array(0 to 15) of std_logic_vector(30 downto 0);
constant MEM7 : ROM7 := ("0000000000000000000000000000000","0001010111001011100111111001011","0001001101101000010000101000001","0010100100110011111000100001101","0001000100100010101101110000111","0010011011101110010101101010010","0010010010001010111110011001001","0011101001010110100110010010100","0000111100110010011001101010101","0010010011111110000001100100000","0010001010011010101010010010111","0011100001100110010010001100010","0010000001010101000111011011100","0011011000100000101111010101000","0011001110111101011000000011110","0100100110001000111111111101001");
type ROM8 is array(0 to 7) of std_logic_vector(29 downto 0);
constant MEM8 : ROM8 := ("000000000000000000000000000000","000110110101100010001111110010","000110010111101011000110101110","001101001101001101010110100000","000110001110101111111010001011","001101000100010010001001111110","001100100110011011000000111010","010011011011111101010000101100");
signal SIG1 :  std_logic_vector(30 downto 0);
signal WE : std_logic;
signal L2 : std_logic_vector(4 downto 0);
signal reg	: std_logic_vector(23 downto 0);
signal INADD : std_logic_vector(34 downto 0);
signal OUT_SM : std_logic_vector(35 downto 0);
signal OUT_4 : std_logic_vector(31 downto 0);
signal OUT_5 : std_logic_vector(31 downto 0);
signal OUT_3 : std_logic_vector(30 downto 0);
signal OUT_1 : std_logic_vector(30 downto 0);
signal OUT_2 : std_logic_vector(30 downto 0);
signal OUT_6 : std_logic_vector(30 downto 0);
signal OUT_7 : std_logic_vector(30 downto 0);
signal OUT_8 : std_logic_vector(29 downto 0);
signal ADD1 : std_logic_vector(32 downto 0);
signal ADD2 : std_logic_vector(31 downto 0);
signal ADD3 : std_logic_vector(32 downto 0);
signal ADD4 : std_logic_vector(31 downto 0);
signal ADD5 : std_logic_vector(33 downto 0);
signal ADD6 : std_logic_vector(33 downto 0);

begin

	WE <= '1';

	L1 : for i in 1 to 30 generate
		RM : RAM32X1S port map(D => SIG1(i-1),A4 => L2(4), A3 => L2(3), A2 => L2(2), A1 => L2(1), A0 => L2(0), WE => WE, WCLK => CLK, O => SIG1(i));
	end generate;

	process(CLK, RESET)
	variable n_r,o_r : std_logic;
	begin
		if RESET = '1' then
			n_r := '1';
			o_r := '0';
			NEW_READY <= '1';
			OUT_READY <= '0';
			RSLT <= (others=>'0');
			L2 <= "10111";
			reg<=(others=>'0');
			SIG1(0) <= '0';
			OUT_SM <= (others=>'0');
			INADD <= (others=>'0');
			OUT_1 <= (others=>'0');
			OUT_2 <= (others=>'0');
			ADD1 <= (others=>'0');
			ADD2 <= (others=>'0');
			OUT_3 <= (others=>'0');
			OUT_4 <= (others=>'0');
			ADD3 <= (others=>'0');
			ADD4 <= (others=>'0');
			ADD5 <= (others=>'0');
			ADD6 <= (others=>'0');
			OUT_5 <= (others=>'0');
			OUT_6 <= (others=>'0');
			OUT_7 <= (others=>'0');
			OUT_8 <= (others=>'0');
		elsif rising_edge(CLK) then
			case L2 is
				when "10111" =>
					L2<="00000"; 
					n_r := '1';
					reg<=DATA;
				when others =>
					L2<=L2+'1';
					n_r := '0';
			end case;

			case L2 is
				when "00100" =>
					OUT_SM <= SXT(OUT_SM(OUT_SM'left downto 1),OUT_SM'left+1) - SXT(INADD,OUT_SM'left+1);
					o_r:='0';
				when "00101" =>
					OUT_SM <= SXT(INADD,OUT_SM'left+1);
					RSLT <= OUT_SM(OUT_SM'left downto OUT_SM'left-23);
					o_r:='1';
				when others =>
					OUT_SM <= SXT(INADD,OUT_SM'left+1) + SXT(OUT_SM(OUT_SM'left downto 1),OUT_SM'left+1);
					o_r:='0';
			end case;

			SIG1(0)<= reg(CONV_INTEGER(L2));
			OUT_1 <= MEM1(CONV_INTEGER(SIG1(2 downto 0)));
			OUT_2 <= MEM2(CONV_INTEGER(SIG1(6 downto 3)));
			OUT_3 <= MEM3(CONV_INTEGER(SIG1(10 downto 7)));
			OUT_4 <= MEM4(CONV_INTEGER(SIG1(14 downto 11)));
			OUT_5 <= MEM5(CONV_INTEGER(SIG1(18 downto 15)));
			OUT_6 <= MEM6(CONV_INTEGER(SIG1(22 downto 19)));
			OUT_7 <= MEM7(CONV_INTEGER(SIG1(26 downto 23)));
			OUT_8 <= MEM8(CONV_INTEGER(SIG1(29 downto 27)));
			ADD1 <= SXT(OUT_4,ADD1'LEFT+1) + SXT(OUT_8,ADD1'LEFT+1);
			ADD2 <= SXT(OUT_1,ADD2'LEFT+1) + SXT(OUT_2,ADD2'LEFT+1);
			ADD3 <= SXT(OUT_5,ADD3'LEFT+1) + SXT(OUT_7,ADD3'LEFT+1);
			ADD4 <= SXT(OUT_3,ADD4'LEFT+1) + SXT(OUT_6,ADD4'LEFT+1);
			ADD5 <= SXT(ADD1,ADD5'LEFT+1) + SXT(ADD2,ADD5'LEFT+1);
			ADD6 <= SXT(ADD3,ADD6'LEFT+1) + SXT(ADD4,ADD6'LEFT+1);
			INADD <= SXT(ADD5,INADD'LEFT+1) + SXT(ADD6,INADD'LEFT+1);
			NEW_READY <= n_r;
			OUT_READY <= o_r;
		end if;
	end process;

end architecture;
